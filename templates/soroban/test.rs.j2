//! Unit tests for {{ contract.name }} NFT Contract
//! Generated by HEAVYMETA Soroban Generator

#![cfg(test)]

use super::*;
use soroban_sdk::{testutils::Address as _, Address, Env, String};

/// Create a test environment with the contract registered
fn setup_env() -> (Env, Address, {{ contract.name }}ContractClient<'static>) {
    let env = Env::default();
    env.mock_all_auths();

    let contract_id = env.register_contract(None, {{ contract.name }}Contract);
    let client = {{ contract.name }}ContractClient::new(&env, &contract_id);
    let admin = Address::generate(&env);

    (env, admin, client)
}

/// Initialize a contract for testing
fn init_contract(
    env: &Env,
    client: &{{ contract.name }}ContractClient,
    admin: &Address,
) {
    client.initialize(
        admin,
        &String::from_str(env, "{{ contract.name }}"),
        &String::from_str(env, "{{ contract.symbol }}"),
        &{{ contract.max_supply }}u64,
    );
}

// ============================================================================
// Initialization Tests
// ============================================================================

#[test]
fn test_initialize() {
    let (env, admin, client) = setup_env();

    let result = client.try_initialize(
        &admin,
        &String::from_str(&env, "{{ contract.name }}"),
        &String::from_str(&env, "{{ contract.symbol }}"),
        &{{ contract.max_supply }}u64,
    );

    assert!(result.is_ok());
    assert_eq!(client.name(), String::from_str(&env, "{{ contract.name }}"));
    assert_eq!(client.symbol(), String::from_str(&env, "{{ contract.symbol }}"));
    assert_eq!(client.max_supply(), {{ contract.max_supply }}u64);
    assert_eq!(client.total_supply(), 0u64);
}

#[test]
fn test_initialize_twice_fails() {
    let (env, admin, client) = setup_env();
    init_contract(&env, &client, &admin);

    let result = client.try_initialize(
        &admin,
        &String::from_str(&env, "Test"),
        &String::from_str(&env, "TST"),
        &100u64,
    );

    assert!(result.is_err());
}

// ============================================================================
// Minting Tests
// ============================================================================

#[test]
fn test_mint() {
    let (env, admin, client) = setup_env();
    init_contract(&env, &client, &admin);

    let user = Address::generate(&env);
    let metadata_cid = String::from_str(&env, "QmTestCID12345");

    let token_id = client.mint(&user, &metadata_cid);

    assert_eq!(token_id, 0u64);
    assert_eq!(client.total_supply(), 1u64);
    assert_eq!(client.balance_of(&user), 1u64);
    assert_eq!(client.owner_of(&token_id), user);
}

#[test]
fn test_mint_multiple() {
    let (env, admin, client) = setup_env();
    init_contract(&env, &client, &admin);

    let user = Address::generate(&env);

    for i in 0..5 {
        let cid = String::from_str(&env, &format!("QmTestCID{}", i));
        let token_id = client.mint(&user, &cid);
        assert_eq!(token_id, i as u64);
    }

    assert_eq!(client.total_supply(), 5u64);
    assert_eq!(client.balance_of(&user), 5u64);
}

// ============================================================================
// Transfer Tests
// ============================================================================

#[test]
fn test_transfer() {
    let (env, admin, client) = setup_env();
    init_contract(&env, &client, &admin);

    let user1 = Address::generate(&env);
    let user2 = Address::generate(&env);
    let metadata_cid = String::from_str(&env, "QmTestCID12345");

    let token_id = client.mint(&user1, &metadata_cid);

    client.transfer(&user1, &user2, &token_id);

    assert_eq!(client.owner_of(&token_id), user2);
    assert_eq!(client.balance_of(&user1), 0u64);
    assert_eq!(client.balance_of(&user2), 1u64);
}

#[test]
fn test_transfer_not_owner_fails() {
    let (env, admin, client) = setup_env();
    init_contract(&env, &client, &admin);

    let user1 = Address::generate(&env);
    let user2 = Address::generate(&env);
    let user3 = Address::generate(&env);
    let metadata_cid = String::from_str(&env, "QmTestCID12345");

    let token_id = client.mint(&user1, &metadata_cid);

    // user2 trying to transfer user1's token should fail
    let result = client.try_transfer(&user2, &user3, &token_id);
    assert!(result.is_err());
}

// ============================================================================
// Value Property Tests
// ============================================================================
{% for name, prop in val_props.items() %}

#[test]
fn test_{{ name }}_initial_value() {
    let (env, admin, client) = setup_env();
    init_contract(&env, &client, &admin);

    let user = Address::generate(&env);
    let metadata_cid = String::from_str(&env, "QmTestCID12345");
    let token_id = client.mint(&user, &metadata_cid);

    assert_eq!(client.get_{{ name }}(&token_id), {{ prop.default }}u64);
}
{% if prop.prop_action_type in ['Incremental', 'Bicremental'] %}

#[test]
fn test_increment_{{ name }}() {
    let (env, admin, client) = setup_env();
    init_contract(&env, &client, &admin);

    let user = Address::generate(&env);
    let metadata_cid = String::from_str(&env, "QmTestCID12345");
    let token_id = client.mint(&user, &metadata_cid);

    let new_value = client.increment_{{ name }}(&user, &token_id);
    assert_eq!(new_value, {{ prop.default }}u64 + {{ prop.amount }}u64);
    assert_eq!(client.get_{{ name }}(&token_id), new_value);
}

#[test]
fn test_increment_{{ name }}_max_boundary() {
    let (env, admin, client) = setup_env();
    init_contract(&env, &client, &admin);

    let user = Address::generate(&env);
    let metadata_cid = String::from_str(&env, "QmTestCID12345");
    let token_id = client.mint(&user, &metadata_cid);

    // Increment until we approach max
    let max_val = {{ prop.max }}u64;
    let amount = {{ prop.amount }}u64;
    let mut current = {{ prop.default }}u64;

    while current + amount <= max_val {
        current = client.increment_{{ name }}(&user, &token_id);
    }

    // Next increment should fail (would exceed max)
    if current + amount > max_val {
        let result = client.try_increment_{{ name }}(&user, &token_id);
        assert!(result.is_err());
    }
}
{% endif %}
{% if prop.prop_action_type in ['Decremental', 'Bicremental'] %}

#[test]
fn test_decrement_{{ name }}() {
    let (env, admin, client) = setup_env();
    init_contract(&env, &client, &admin);

    let user = Address::generate(&env);
    let metadata_cid = String::from_str(&env, "QmTestCID12345");
    let token_id = client.mint(&user, &metadata_cid);
{% if prop.prop_action_type == 'Bicremental' %}
    // First increment to have room to decrement
    client.increment_{{ name }}(&user, &token_id);
{% endif %}
{% if prop.default >= prop.amount and prop.default - prop.amount >= prop.min %}
    let new_value = client.decrement_{{ name }}(&user, &token_id);
    assert_eq!(client.get_{{ name }}(&token_id), new_value);
{% else %}
    // Default value is already at or below minimum + amount, decrement should fail
    let result = client.try_decrement_{{ name }}(&user, &token_id);
    // May succeed or fail depending on default value
    let _ = result;
{% endif %}
}

#[test]
fn test_decrement_{{ name }}_min_boundary() {
    let (env, admin, client) = setup_env();
    init_contract(&env, &client, &admin);

    let user = Address::generate(&env);
    let metadata_cid = String::from_str(&env, "QmTestCID12345");
    let token_id = client.mint(&user, &metadata_cid);

    // Decrement until we reach minimum
    let min_val = {{ prop.min }}u64;
    let amount = {{ prop.amount }}u64;
    let mut current = client.get_{{ name }}(&token_id);

    while current >= min_val + amount {
        match client.try_decrement_{{ name }}(&user, &token_id) {
            Ok(Ok(val)) => current = val,
            _ => break,
        }
    }

    // At or near minimum, further decrement should fail
    if current < amount || current - amount < min_val {
        let result = client.try_decrement_{{ name }}(&user, &token_id);
        assert!(result.is_err() || matches!(result, Ok(Err(_))));
    }
}
{% endif %}
{% if prop.prop_action_type == 'Setter' %}

#[test]
fn test_set_{{ name }}() {
    let (env, admin, client) = setup_env();
    init_contract(&env, &client, &admin);

    let user = Address::generate(&env);
    let metadata_cid = String::from_str(&env, "QmTestCID12345");
    let token_id = client.mint(&user, &metadata_cid);

    let test_value = ({{ prop.min }}u64 + {{ prop.max }}u64) / 2;
    let new_value = client.set_{{ name }}(&user, &token_id, &test_value);
    assert_eq!(new_value, test_value);
    assert_eq!(client.get_{{ name }}(&token_id), test_value);
}

#[test]
fn test_set_{{ name }}_out_of_range_fails() {
    let (env, admin, client) = setup_env();
    init_contract(&env, &client, &admin);

    let user = Address::generate(&env);
    let metadata_cid = String::from_str(&env, "QmTestCID12345");
    let token_id = client.mint(&user, &metadata_cid);

    // Test value above max
    let result = client.try_set_{{ name }}(&user, &token_id, &({{ prop.max }}u64 + 1));
    assert!(result.is_err() || matches!(result, Ok(Err(_))));
{% if prop.min > 0 %}
    // Test value below min
    let result = client.try_set_{{ name }}(&user, &token_id, &({{ prop.min }}u64 - 1));
    assert!(result.is_err() || matches!(result, Ok(Err(_))));
{% endif %}
}
{% endif %}

#[test]
fn test_get_{{ name }}_config() {
    let (env, admin, client) = setup_env();
    init_contract(&env, &client, &admin);

    let config = client.get_{{ name }}_config();
    assert_eq!(config.default, {{ prop.default }}u64);
    assert_eq!(config.min, {{ prop.min }}u64);
    assert_eq!(config.max, {{ prop.max }}u64);
    assert_eq!(config.amount, {{ prop.amount }}u64);
}
{% endfor %}

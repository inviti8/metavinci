//! {{ contract.name }} NFT Contract
//! Generated by HEAVYMETA Soroban Generator
//!
//! NFT Type: {{ contract.nft_type }}
//! Symbol: {{ contract.symbol }}
//! Max Supply: {{ contract.max_supply }}

#![no_std]

use soroban_sdk::{contract, contractimpl, Address, Env, String, Vec, vec};

mod types;
mod storage;

use types::*;
use storage::*;

#[contract]
pub struct {{ contract.name }}Contract;

#[contractimpl]
impl {{ contract.name }}Contract {
    // ============================================================================
    // Initialization
    // ============================================================================

    /// Initialize the NFT contract with admin and metadata
    ///
    /// # Arguments
    /// * `env` - The contract environment
    /// * `admin` - The admin address with special privileges
    /// * `name` - The collection name
    /// * `symbol` - The token symbol
    /// * `max_supply` - Maximum number of tokens that can be minted
    pub fn initialize(
        env: Env,
        admin: Address,
        name: String,
        symbol: String,
        max_supply: u64,
    ) -> Result<(), Error> {
        // Check if already initialized
        if env.storage().instance().has(&DataKey::Initialized) {
            return Err(Error::AlreadyInitialized);
        }

        // Require admin authorization
        admin.require_auth();

        // Store contract metadata
        env.storage().instance().set(&DataKey::Admin, &admin);
        env.storage().instance().set(&DataKey::Name, &name);
        env.storage().instance().set(&DataKey::Symbol, &symbol);
        env.storage().instance().set(&DataKey::MaxSupply, &max_supply);
        env.storage().instance().set(&DataKey::TotalSupply, &0u64);
        env.storage().instance().set(&DataKey::NftType, &String::from_str(&env, "{{ contract.nft_type }}"));
        env.storage().instance().set(&DataKey::Initialized, &true);

        // Extend storage TTL
        env.storage().instance().extend_ttl(INSTANCE_LIFETIME_THRESHOLD, INSTANCE_BUMP_AMOUNT);

        Ok(())
    }

    // ============================================================================
    // NFT Core Functions
    // ============================================================================

    /// Mint a new NFT to the specified address
    ///
    /// # Arguments
    /// * `env` - The contract environment
    /// * `to` - The recipient address
    /// * `metadata_cid` - IPFS CID for the token metadata
    ///
    /// # Returns
    /// The newly minted token ID
    pub fn mint(env: Env, to: Address, metadata_cid: String) -> Result<u64, Error> {
        Self::require_initialized(&env)?;

        // Require recipient authorization
        to.require_auth();

        // Check supply
        let total_supply: u64 = env.storage().instance().get(&DataKey::TotalSupply).unwrap_or(0);
        let max_supply: u64 = env.storage().instance().get(&DataKey::MaxSupply).unwrap_or(0);

        if total_supply >= max_supply {
            return Err(Error::MaxSupplyReached);
        }

        // Create new token
        let token_id = total_supply;
        let nft = Nft {
            owner: to.clone(),
            id: token_id,
            metadata_cid,
        };

        // Store NFT data
        env.storage().persistent().set(&DataKey::Nft(token_id), &nft);
        env.storage().persistent().extend_ttl(
            &DataKey::Nft(token_id),
            PERSISTENT_LIFETIME_THRESHOLD,
            PERSISTENT_BUMP_AMOUNT,
        );

        // Update balance
        let balance: u64 = env.storage().persistent().get(&DataKey::Balance(to.clone())).unwrap_or(0);
        env.storage().persistent().set(&DataKey::Balance(to.clone()), &(balance + 1));

        // Update owned tokens list
        let mut owned: Vec<u64> = env.storage().persistent()
            .get(&DataKey::OwnedTokens(to.clone()))
            .unwrap_or(vec![&env]);
        owned.push_back(token_id);
        env.storage().persistent().set(&DataKey::OwnedTokens(to.clone()), &owned);

        // Update total supply
        env.storage().instance().set(&DataKey::TotalSupply, &(total_supply + 1));

        // Initialize value properties at default values
{% for name, prop in val_props.items() %}
        env.storage().persistent().set(&DataKey::{{ name | capitalize }}(token_id), &{{ name | upper }}_DEFAULT);
{% endfor %}

        // Extend storage TTL
        env.storage().instance().extend_ttl(INSTANCE_LIFETIME_THRESHOLD, INSTANCE_BUMP_AMOUNT);

        Ok(token_id)
    }

    /// Transfer an NFT from one address to another
    ///
    /// # Arguments
    /// * `env` - The contract environment
    /// * `from` - The current owner address
    /// * `to` - The recipient address
    /// * `token_id` - The token ID to transfer
    pub fn transfer(env: Env, from: Address, to: Address, token_id: u64) -> Result<(), Error> {
        Self::require_initialized(&env)?;

        // Require sender authorization
        from.require_auth();

        // Get NFT and verify ownership
        let mut nft: Nft = env.storage().persistent()
            .get(&DataKey::Nft(token_id))
            .ok_or(Error::InvalidTokenId)?;

        if nft.owner != from {
            return Err(Error::NotOwner);
        }

        // Update NFT owner
        nft.owner = to.clone();
        env.storage().persistent().set(&DataKey::Nft(token_id), &nft);

        // Update sender balance
        let from_balance: u64 = env.storage().persistent()
            .get(&DataKey::Balance(from.clone()))
            .unwrap_or(0);
        if from_balance > 0 {
            env.storage().persistent().set(&DataKey::Balance(from.clone()), &(from_balance - 1));
        }

        // Update recipient balance
        let to_balance: u64 = env.storage().persistent()
            .get(&DataKey::Balance(to.clone()))
            .unwrap_or(0);
        env.storage().persistent().set(&DataKey::Balance(to.clone()), &(to_balance + 1));

        // Update owned tokens lists
        let mut from_owned: Vec<u64> = env.storage().persistent()
            .get(&DataKey::OwnedTokens(from.clone()))
            .unwrap_or(vec![&env]);

        // Remove token from sender's list
        let mut new_from_owned: Vec<u64> = vec![&env];
        for i in 0..from_owned.len() {
            let tid = from_owned.get(i).unwrap();
            if tid != token_id {
                new_from_owned.push_back(tid);
            }
        }
        env.storage().persistent().set(&DataKey::OwnedTokens(from), &new_from_owned);

        // Add token to recipient's list
        let mut to_owned: Vec<u64> = env.storage().persistent()
            .get(&DataKey::OwnedTokens(to.clone()))
            .unwrap_or(vec![&env]);
        to_owned.push_back(token_id);
        env.storage().persistent().set(&DataKey::OwnedTokens(to), &to_owned);

        // Extend storage TTL
        env.storage().persistent().extend_ttl(
            &DataKey::Nft(token_id),
            PERSISTENT_LIFETIME_THRESHOLD,
            PERSISTENT_BUMP_AMOUNT,
        );

        Ok(())
    }

    /// Get the balance of tokens owned by an address
    pub fn balance_of(env: Env, owner: Address) -> u64 {
        env.storage().persistent()
            .get(&DataKey::Balance(owner))
            .unwrap_or(0)
    }

    /// Get the owner of a specific token
    pub fn owner_of(env: Env, token_id: u64) -> Result<Address, Error> {
        let nft: Nft = env.storage().persistent()
            .get(&DataKey::Nft(token_id))
            .ok_or(Error::InvalidTokenId)?;
        Ok(nft.owner)
    }

    /// Get the total supply of minted tokens
    pub fn total_supply(env: Env) -> u64 {
        env.storage().instance()
            .get(&DataKey::TotalSupply)
            .unwrap_or(0)
    }

    /// Get the maximum supply of tokens
    pub fn max_supply(env: Env) -> u64 {
        env.storage().instance()
            .get(&DataKey::MaxSupply)
            .unwrap_or(0)
    }

    /// Get NFT metadata by token ID
    pub fn get_nft(env: Env, token_id: u64) -> Result<Nft, Error> {
        env.storage().persistent()
            .get(&DataKey::Nft(token_id))
            .ok_or(Error::InvalidTokenId)
    }

    /// Get all token IDs owned by an address
    pub fn tokens_of(env: Env, owner: Address) -> Vec<u64> {
        env.storage().persistent()
            .get(&DataKey::OwnedTokens(owner))
            .unwrap_or(vec![&env])
    }

    /// Get contract name
    pub fn name(env: Env) -> String {
        env.storage().instance()
            .get(&DataKey::Name)
            .unwrap_or(String::from_str(&env, ""))
    }

    /// Get token symbol
    pub fn symbol(env: Env) -> String {
        env.storage().instance()
            .get(&DataKey::Symbol)
            .unwrap_or(String::from_str(&env, ""))
    }

    // ============================================================================
    // Value Properties
    // ============================================================================
{% for name, prop in val_props.items() %}

    // ---------- {{ name | capitalize }} Property ----------
{% if prop.prop_action_type in ['Incremental', 'Bicremental'] %}

    /// Increment the {{ name }} value for a token
    ///
    /// # Arguments
    /// * `env` - The contract environment
    /// * `owner` - The token owner (must authorize)
    /// * `token_id` - The token ID
    ///
    /// # Returns
    /// The new {{ name }} value after incrementing
    pub fn increment_{{ name }}(env: Env, owner: Address, token_id: u64) -> Result<{{ prop.value_type }}, Error> {
        Self::require_initialized(&env)?;

        // Require owner authorization
        owner.require_auth();

        // Verify ownership
        let nft: Nft = env.storage().persistent()
            .get(&DataKey::Nft(token_id))
            .ok_or(Error::InvalidTokenId)?;

        if nft.owner != owner {
            return Err(Error::NotOwner);
        }

        // Get current value
        let current: {{ prop.value_type }} = env.storage().persistent()
            .get(&DataKey::{{ name | capitalize }}(token_id))
            .unwrap_or({{ name | upper }}_DEFAULT);

        // Calculate new value with overflow check
        let new_value = current.saturating_add({{ name | upper }}_AMOUNT);

        // Check bounds
        if new_value > {{ name | upper }}_MAX {
            return Err(Error::OutOfRange);
        }

        // Store new value
        env.storage().persistent().set(&DataKey::{{ name | capitalize }}(token_id), &new_value);

        Ok(new_value)
    }
{% endif %}
{% if prop.prop_action_type in ['Decremental', 'Bicremental'] %}

    /// Decrement the {{ name }} value for a token
    ///
    /// # Arguments
    /// * `env` - The contract environment
    /// * `owner` - The token owner (must authorize)
    /// * `token_id` - The token ID
    ///
    /// # Returns
    /// The new {{ name }} value after decrementing
    pub fn decrement_{{ name }}(env: Env, owner: Address, token_id: u64) -> Result<{{ prop.value_type }}, Error> {
        Self::require_initialized(&env)?;

        // Require owner authorization
        owner.require_auth();

        // Verify ownership
        let nft: Nft = env.storage().persistent()
            .get(&DataKey::Nft(token_id))
            .ok_or(Error::InvalidTokenId)?;

        if nft.owner != owner {
            return Err(Error::NotOwner);
        }

        // Get current value
        let current: {{ prop.value_type }} = env.storage().persistent()
            .get(&DataKey::{{ name | capitalize }}(token_id))
            .unwrap_or({{ name | upper }}_DEFAULT);

        // Check if we can decrement
        if current < {{ name | upper }}_AMOUNT {
            return Err(Error::OutOfRange);
        }

        let new_value = current - {{ name | upper }}_AMOUNT;

        // Check lower bound
        if new_value < {{ name | upper }}_MIN {
            return Err(Error::OutOfRange);
        }

        // Store new value
        env.storage().persistent().set(&DataKey::{{ name | capitalize }}(token_id), &new_value);

        Ok(new_value)
    }
{% endif %}
{% if prop.prop_action_type == 'Setter' %}

    /// Set the {{ name }} value for a token
    ///
    /// # Arguments
    /// * `env` - The contract environment
    /// * `owner` - The token owner (must authorize)
    /// * `token_id` - The token ID
    /// * `value` - The new value to set
    ///
    /// # Returns
    /// The new {{ name }} value after setting
    pub fn set_{{ name }}(env: Env, owner: Address, token_id: u64, value: {{ prop.value_type }}) -> Result<{{ prop.value_type }}, Error> {
        Self::require_initialized(&env)?;

        // Require owner authorization
        owner.require_auth();

        // Verify ownership
        let nft: Nft = env.storage().persistent()
            .get(&DataKey::Nft(token_id))
            .ok_or(Error::InvalidTokenId)?;

        if nft.owner != owner {
            return Err(Error::NotOwner);
        }

        // Check bounds
        if value < {{ name | upper }}_MIN || value > {{ name | upper }}_MAX {
            return Err(Error::OutOfRange);
        }

        // Store new value
        env.storage().persistent().set(&DataKey::{{ name | capitalize }}(token_id), &value);

        Ok(value)
    }
{% endif %}

    /// Get the {{ name }} value for a token
    ///
    /// # Arguments
    /// * `env` - The contract environment
    /// * `token_id` - The token ID
    ///
    /// # Returns
    /// The current {{ name }} value
    pub fn get_{{ name }}(env: Env, token_id: u64) -> {{ prop.value_type }} {
        env.storage().persistent()
            .get(&DataKey::{{ name | capitalize }}(token_id))
            .unwrap_or({{ name | upper }}_DEFAULT)
    }

    /// Get the {{ name }} property configuration
    pub fn get_{{ name }}_config(env: Env) -> ValueProperty {
        // Suppress unused variable warning
        let _ = &env;
        ValueProperty {
            default: {{ name | upper }}_DEFAULT,
            min: {{ name | upper }}_MIN,
            max: {{ name | upper }}_MAX,
            amount: {{ name | upper }}_AMOUNT,
        }
    }
{% endfor %}

    // ============================================================================
    // Internal Helpers
    // ============================================================================

    /// Check if the contract is initialized
    fn require_initialized(env: &Env) -> Result<(), Error> {
        if !env.storage().instance().has(&DataKey::Initialized) {
            return Err(Error::NotInitialized);
        }
        Ok(())
    }
}

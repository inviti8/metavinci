name: Build Cross-Platform Installers

on:
  push:
    tags:
      - 'v0.[0-9][0-9]*'   # v0.00, v0.01, v0.02, etc.
      - '*installers*'     # Any tag containing 'installers'
  workflow_dispatch:

permissions:
  contents: write
  actions: read

jobs:
  build-linux-installer:
    runs-on: ubuntu-22.04
    # Linux-specific build job - using ubuntu-22.04 for current compatibility
    # Note: ubuntu-20.04 was deprecated, ubuntu-22.04 provides glibc 2.35 which is widely compatible
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python 3.11
        uses: actions/setup-python@v4
        with:
          python-version: 3.11

      - name: Install Python dependencies for Linux
        run: |
          echo "=== Installing Python dependencies ==="
          python -m pip install --upgrade pip
          echo "Pip upgraded to: $(pip --version)"
          
          echo "Installing requirements.txt..."
          pip install -r requirements.txt
          echo "Installing build dependencies..."
          pip install pyinstaller Pillow icnsutil
          
          echo "=== Installed packages ==="
          pip list | grep -E "(pyinstaller|pillow|icnsutil|pyqt5)" || echo "Some packages not found in pip list"
          echo "=== Python version and location ==="
          python --version
          which python
          echo "=== Current directory and files ==="
          pwd
          ls -la
          
          echo "=== PyInstaller version and info ==="
          pyinstaller --version || echo "PyInstaller not found in PATH"
          which pyinstaller || echo "PyInstaller not in PATH"

      - name: Install system Qt libraries (Linux only)
        run: |
          echo "=== Installing system Qt libraries ==="
          echo "Current system info:"
          cat /etc/os-release
          echo "Available memory:"
          free -h
          echo "Disk space:"
          df -h
          
          sudo apt-get update
          echo "Installing Qt dependencies..."
          sudo apt-get install -y libxcb-xinerama0 libxcb-xinerama0-dev libxcb1 libxkbcommon-x11-0 libxcb-icccm4 libxcb-image0 libxcb-keysyms1 libxcb-render-util0 libxcb-shape0 libxcb-randr0 libxcb-xfixes0 libxcb-sync1 libxcb-xkb1 libxkbcommon-x11-0
          
          echo "=== Qt libraries installed ==="
          echo "Checking for Qt libraries:"
          ldconfig -p | grep -E "(xcb|qt)" | head -20 || echo "No Qt libraries found in ldconfig"

      - name: Build Linux installer
        run: |
          echo "=== Building Linux installer ==="
          echo "Environment variables:"
          env | grep -E "(PATH|PYTHON|QT)" | head -20
          
          echo "Checking build script exists:"
          ls -la build_installers.py
          
          echo "Checking source files:"
          ls -la *.py *.qrc
          
          echo "Starting build process..."
          python build_installers.py --platform linux --version ${{ github.ref_name }}
          
          echo "=== Build completed ==="
          echo "Build output directory:"
          ls -la build/ || echo "Build directory not found"
          echo "Release directory:"
          ls -la release/ || echo "Release directory not found"
          
          echo "=== Checking for .deb file ==="
          find . -name "*.deb" -type f 2>/dev/null || echo "No .deb files found"
          echo "=== Checking file permissions ==="
          ls -la release/linux/ 2>/dev/null || echo "Linux release directory not accessible"
          
          echo "=== Testing built executable ==="
          if [ -f "build/dist/linux/metavinci" ]; then
            echo "Executable found, checking size and permissions:"
            ls -la build/dist/linux/metavinci
            echo "Checking if executable can run (should show help):"
            timeout 10s build/dist/linux/metavinci --help || echo "Executable failed to run or timed out"
          else
            echo "Executable not found at expected location"
            find build/ -name "metavinci" -type f 2>/dev/null || echo "No metavinci executable found anywhere"
          fi
          
          echo "=== Final artifact check ==="
          echo "Looking for .deb files:"
          find . -name "*.deb" -type f -exec ls -la {} \; 2>/dev/null || echo "No .deb files found"
          echo "Checking release directory structure:"
          tree release/ 2>/dev/null || echo "Tree command not available or release directory not found"

      - name: Upload Linux installer
        uses: actions/upload-artifact@v4
        with:
          name: metavinci-linux-installer
          path: release/linux/*.deb
          retention-days: 30

  build-windows-installer:
    runs-on: windows-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python 3.11
      uses: actions/setup-python@v4
      with:
        python-version: 3.11

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pyinstaller Pillow icnsutil

    - name: Install cx_Freeze
      run: pip install cx_Freeze

    - name: Generate icons
      run: python generate_icons.py

    - name: List files after icon generation
      run: |
        echo "==================== PROJECT ROOT FILES (AFTER ICON GENERATION) ===================="
        dir
        echo "==============================================================================="

    - name: Check cx_Freeze version and location
      run: |
        python -c "import cx_Freeze; print('cx_Freeze version:', cx_Freeze.__version__); print('cx_Freeze location:', cx_Freeze.__file__)"
        python -c "import setuptools; print('setuptools location:', setuptools.__file__)"

    - name: Build Windows installer (PyInstaller + cx_Freeze)
      run: |
        echo "=== Building Windows installer ==="
        echo "Current directory:"
        pwd
        echo "Source files:"
        dir *.py *.qrc
        echo "Starting build..."
        python build_installers.py --platform windows --version ${{ github.ref_name }}
        echo "=== Build completed ==="
        echo "Build output:"
        dir build\ || echo "Build directory not found"
        echo "Dist output:"
        dir dist\ || echo "Dist directory not found"

    - name: Download lessmsi
      run: |
        curl -L -o lessmsi.zip https://github.com/activescott/lessmsi/releases/download/v1.10.0/lessmsi-v1.10.0.zip
        tar -xf lessmsi.zip
        
    - name: Sign Windows MSI and prepare certificate
      if: success()
      run: |
        # Create a temporary directory for certificate files
        $tempDir = "$env:RUNNER_TEMP\certs"
        New-Item -ItemType Directory -Path $tempDir -Force | Out-Null
        
        # Write the PFX certificate to a secure temporary file
        $certBytes = [System.Convert]::FromBase64String("${{ secrets.WINDOWS_SIGNING_CERT }}")
        $pfxPath = "$tempDir\heavymeta-code-sign.pfx"
        [System.IO.File]::WriteAllBytes($pfxPath, $certBytes)
        
        # Export the public certificate using certutil (more reliable cross-platform)
        $publicCertPath = "$tempDir\heavymeta-code-sign.cer"
        $password = "${{ secrets.WINDOWS_SIGNING_PASSWORD }}"
        
        # First, import the certificate to the temporary store
        $certStore = New-Object System.Security.Cryptography.X509Certificates.X509Store("My", "CurrentUser")
        $certStore.Open("ReadWrite")
        
        try {
            $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2(
                $pfxPath,
                $password,
                [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::Exportable
            )
            $certStore.Add($cert)
            
            # Export the public certificate
            $publicCertData = $cert.Export([System.Security.Cryptography.X509Certificates.X509ContentType]::Cert)
            [System.IO.File]::WriteAllBytes($publicCertPath, $publicCertData)
            
            Write-Host "Successfully exported public certificate to: $publicCertPath"
        }
        finally {
            # Clean up the certificate from the store
            if ($cert) {
                $certStore.Remove($cert)
            }
            $certStore.Close()
        }
        
        # Sign the MSI using the installed Windows SDK signtool
        $signTool = "$env:ProgramFiles (x86)\Windows Kits\10\bin\10.0.22621.0\x64\signtool.exe"
        
        # Look for MSI in both root dist and build/dist directories
        $msiFile = (Get-ChildItem -Path "dist\*.msi" -ErrorAction SilentlyContinue | Select-Object -First 1).FullName
        if (-not $msiFile) {
            $msiFile = (Get-ChildItem -Path "build\dist\*.msi" -ErrorAction SilentlyContinue | Select-Object -First 1).FullName
        }
        
        if (-not $msiFile) {
            Write-Host "##[error] MSI file not found in expected locations"
            Write-Host "##[debug] Current directory: $(Get-Location)"
            Write-Host "##[debug] Directory contents:"
            Get-ChildItem -Recurse -Filter "*.msi" | Format-Table FullName
            exit 1
        }
        
        Write-Host "##[info] Found MSI file at: $msiFile"
        
        # First, try to sign with the original PFX file
        Write-Host "##[info] Attempting to sign with PFX file..."
        & "$signTool" sign `
            /f "$pfxPath" `
            /p "$password" `
            /fd sha256 `
            /td sha256 `
            /tr "http://timestamp.digicert.com" `
            /v `
            "$msiFile"
        
        # If that fails, try with the certificate from the store
        if ($LASTEXITCODE -ne 0) {
            Write-Host "##[warning] PFX signing failed, trying with certificate from store..."
            $certThumbprint = $cert.Thumbprint
            & "$signTool" sign `
                /sha1 "$certThumbprint" `
                /fd sha256 `
                /td sha256 `
                /tr "http://timestamp.digicert.com" `
                /v `
                "$msiFile"
        }
        
        # Verify the signature (using /a to find all valid certs in the chain)
        if (Test-Path $msiFile) {
            Write-Host "##[info] Verifying signature with signtool..."
            & "$signTool" verify /pa /v /a "$msiFile"
            if ($LASTEXITCODE -ne 0) {
                Write-Host "##[warning] Standard verification failed, trying with /all flag..."
                & "$signTool" verify /pa /v /all "$msiFile"
                if ($LASTEXITCODE -ne 0) {
                    Write-Host "##[warning] Note: Verification warnings are expected with self-signed certificates"
                    # Don't fail the build for verification issues with self-signed certs
                    $global:LASTEXITCODE = 0
                }
            }
        } else {
            Write-Host "##[error] Error: MSI file not found at $msiFile"
            Get-ChildItem -Path "dist" -Recurse -ErrorAction SilentlyContinue | Format-Table FullName
            exit 1
        }
        
        # Clean up the certificate files
        if (Test-Path $pfxPath) {
            Remove-Item -Path $pfxPath -Force -ErrorAction SilentlyContinue
        }

    - name: Prepare Windows artifacts
      run: |
        # Create a directory for Windows artifacts
        $artifactDir = "windows-artifacts"
        New-Item -ItemType Directory -Path $artifactDir -Force | Out-Null
        
        # Copy MSI files
        Copy-Item -Path "dist\*.msi" -Destination $artifactDir -Force
        
        # Copy certificate script
        Copy-Item -Path "scripts\install-win-metavinci-cert.ps1" -Destination $artifactDir -Force
        
        # Copy certificate to the artifact directory
        $certSource = "$env:RUNNER_TEMP\certs\heavymeta-code-sign.cer"
        if (Test-Path $certSource) {
            Copy-Item -Path $certSource -Destination $artifactDir -Force
        } else {
            Write-Host "##[warning] Certificate file not found at: $certSource"
        }
        
        # Verify files were copied
        Write-Host "##[info] Windows artifacts prepared:"
        Get-ChildItem -Path $artifactDir -Recurse | Format-Table FullName
      
    - name: Upload Windows artifacts
      uses: actions/upload-artifact@v4
      with:
        name: metavinci-windows-msi-installer
        path: windows-artifacts/*
        retention-days: 30
        retention-days: 30

  build-macos-installer:
    environment: installers
    runs-on: ${{ matrix.runner }}
    strategy:
      matrix:
        include:
          - runner: macos-13
            arch: amd64
          - runner: macos-latest
            arch: arm64
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python 3.11
        uses: actions/setup-python@v4
        with:
          python-version: 3.11

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller Pillow icnsutil

      - name: Build macOS installer
        run: |
          echo "=== Building macOS installer ==="
          echo "Current directory:"
          pwd
          echo "Source files:"
          ls -la *.py *.qrc
          echo "Starting build..."
          python build_installers.py --platform macos --version ${{ github.ref_name }}
          echo "=== Build completed ==="
          echo "Build output:"
          ls -la build/ || echo "Build directory not found"
          echo "Release output:"
          ls -la release/ || echo "Release directory not found"

      - name: List .app bundles
        run: |
          echo "Listing contents of build/dist/mac/:"
          ls -lR build/dist/mac/

      - name: Ensure .app bundle exists
        run: |
          if [ -d build/dist/mac/metavinci_desktop ] && [ ! -d build/dist/mac/metavinci_desktop.app ]; then
            echo "Renaming 'metavinci_desktop' to 'metavinci_desktop.app'"
            mv build/dist/mac/metavinci_desktop build/dist/mac/metavinci_desktop.app
          elif [ -d build/dist/mac/metavinci_desktop.app ]; then
            echo "'metavinci_desktop.app' already exists."
          else
            echo "No 'metavinci_desktop' or 'metavinci_desktop.app' found in build/dist/mac/"
            exit 1
          fi

      - name: List contents of .app bundle
        run: |
          echo "Listing contents of build/dist/mac/metavinci_desktop.app:"
          ls -lR build/dist/mac/metavinci_desktop.app || echo "No .app bundle found"

      - name: List contents of MacOS directory
        run: |
          ls -l build/dist/mac/metavinci_desktop.app/Contents/MacOS || echo "No MacOS directory"

      - name: List contents of Resources directory
        run: |
          ls -l build/dist/mac/metavinci_desktop.app/Contents/Resources || echo "No Resources directory"

      - name: Final check for .app bundle (absolute path)
        run: |
          APP_BUNDLE="$(pwd)/build/dist/mac/metavinci_desktop.app"
          echo "Absolute path: $APP_BUNDLE"
          ls -ld "$APP_BUNDLE"
          ls -l "$APP_BUNDLE"

      - name: Create temporary keychain and import Developer ID certificates
        env:
          MACOS_APPLICATION_P12: ${{ secrets.MACOS_APPLICATION_P12 }}
          MACOS_INSTALLER_P12: ${{ secrets.MACOS_INSTALLER_P12 }}
          MACOS_CERT_PW: ${{ secrets.MACOS_CERT_PW }}
        run: |
          set -eo pipefail

          # Generate a random keychain password at runtime and mask it
          KC_PW="$(openssl rand -base64 32)"
          echo "::add-mask::$KC_PW"

          # Create and unlock a build-scoped keychain
          security create-keychain -p "$KC_PW" build.keychain
          security set-keychain-settings -lut 21600 build.keychain
          security unlock-keychain -p "$KC_PW" build.keychain
          security list-keychains -d user -s build.keychain login.keychain
          security default-keychain -s build.keychain
          echo "Default keychain set to: $(security default-keychain | tr -d '"')"

          # Import Application signing certificate (.p12)
          echo "$MACOS_APPLICATION_P12" | base64 -D > app.p12
          security import app.p12 -k build.keychain -P "$MACOS_CERT_PW" -T /usr/bin/codesign

          # Import Installer signing certificate (.p12) (kept for future .pkg signing)
          echo "$MACOS_INSTALLER_P12" | base64 -D > installer.p12
          security import installer.p12 -k build.keychain -P "$MACOS_CERT_PW" -T /usr/bin/productsign || true

          # Allow codesign/productsign to access the imported keys non-interactively
          security set-key-partition-list -S "apple-tool:,apple:" -s -k "$KC_PW" build.keychain

          # Capture identities (use SHA-1 hash which is most robust for -s)
          APP_IDENTITY_HASH=$(security find-identity -v -p codesigning build.keychain | grep "Developer ID Application" | head -n1 | awk '{print $2}')
          if [ -z "$APP_IDENTITY_HASH" ]; then
            echo "Failed to locate 'Developer ID Application' identity in keychain" >&2
            security find-identity -v -p codesigning build.keychain | cat
            exit 1
          fi
          echo "Using Application identity: $APP_IDENTITY_HASH"

          echo "Available signing identities in build.keychain:" 
          security find-identity -v -p codesigning build.keychain | cat

          echo "APP_IDENTITY_HASH=$APP_IDENTITY_HASH" >> "$GITHUB_ENV"

      - name: Code sign .app with hardened runtime
        run: |
          set -eo pipefail
          APP_BUNDLE="$(pwd)/build/dist/mac/metavinci_desktop.app"
          if [ ! -d "$APP_BUNDLE" ]; then
            echo "App bundle not found at $APP_BUNDLE" >&2
            exit 1
          fi

          # Sign the entire bundle. While --deep is not ideal, it helps cover nested items in simple apps.
          codesign --force --options runtime --timestamp \
            --sign "$APP_IDENTITY_HASH" --deep "$APP_BUNDLE"

          # Verify signature
          codesign --verify --deep --strict --verbose=2 "$APP_BUNDLE" | cat
          spctl -a -vv "$APP_BUNDLE" | cat || true

          echo "Signed app details:"
          codesign -dv --verbose=4 "$APP_BUNDLE" 2>&1 | cat || true

      - name: Create DMG from .app bundle
        run: |
          APP_BUNDLE="$(pwd)/build/dist/mac/metavinci_desktop.app"
          if [ ! -d "$APP_BUNDLE" ]; then
            echo "No .app bundle found at $APP_BUNDLE"
            exit 1
          fi
          mkdir -p release/mac
          ARCH="${{ matrix.arch }}"
          hdiutil create -volname "Metavinci" -srcfolder "$APP_BUNDLE" -ov -format UDZO "release/mac/metavinci_desktop_${{ github.ref_name }}_${ARCH}.dmg"

      - name: Code sign DMG
        run: |
          set -eo pipefail
          ARCH="${{ matrix.arch }}"
          DMG_PATH="release/mac/metavinci_desktop_${{ github.ref_name }}_${ARCH}.dmg"
          if [ ! -f "$DMG_PATH" ]; then
            echo "DMG not found at $DMG_PATH" >&2
            exit 1
          fi
          codesign --force --timestamp --sign "$APP_IDENTITY_HASH" "$DMG_PATH"

          echo "Signed DMG details:"
          codesign -dv --verbose=4 "$DMG_PATH" 2>&1 | cat || true

      - name: Verify DMG integrity
        run: |
          ARCH="${{ matrix.arch }}"
          DMG_PATH="release/mac/metavinci_desktop_${{ github.ref_name }}_${ARCH}.dmg"
          echo "Verifying DMG at $DMG_PATH"
          hdiutil verify "$DMG_PATH"
          echo "Attempting to mount DMG..."
          MOUNT_OUTPUT=$(hdiutil attach "$DMG_PATH" -nobrowse -readonly)
          echo "$MOUNT_OUTPUT"
          MOUNT_POINT=$(echo "$MOUNT_OUTPUT" | grep Volumes | awk '{print $3}')
          if [ -z "$MOUNT_POINT" ]; then
            echo "Failed to mount DMG."
            exit 1
          fi
          echo "Mounted at $MOUNT_POINT"
          ls -lR "$MOUNT_POINT"
          hdiutil detach "$MOUNT_POINT"

      - name: Notarize DMG with Apple ID (notarytool)
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_ID_APP_PW: ${{ secrets.APPLE_ID_APP_PW }}
        run: |
          set -eo pipefail
          ARCH="${{ matrix.arch }}"
          DMG_PATH="release/mac/metavinci_desktop_${{ github.ref_name }}_${ARCH}.dmg"

          # Store credentials in the temporary keychain profile
          xcrun notarytool store-credentials "AC_PROFILE" \
            --apple-id "$APPLE_ID" \
            --team-id "$APPLE_TEAM_ID" \
            --password "$APPLE_ID_APP_PW"

          # Submit (non-blocking) and capture JSON to extract submission id
          echo "Submitting $DMG_PATH to Apple notarization service..."
          xcrun notarytool submit "$DMG_PATH" --keychain-profile "AC_PROFILE" --output-format json | tee notarytool_submit.json

          SUBMISSION_ID=$(python3 -c "import json,sys;print(json.load(open('notarytool_submit.json')).get('id',''))" || echo "")
          if [ -z "$SUBMISSION_ID" ]; then
            echo "Error: Could not extract submission id from notarytool submission output" >&2
            cat notarytool_submit.json || true
            exit 1
          fi
          echo "Notarytool submission id: $SUBMISSION_ID"

          echo "Waiting for notarization result (up to 20 minutes)..."
          # Use notarytool wait with a timeout (older Xcode may not support --poll-interval)
          xcrun notarytool wait "$SUBMISSION_ID" --keychain-profile "AC_PROFILE" --timeout 1200 --output-format json | tee notarytool_wait.json

          # Show the notarization log regardless of result
          echo "Fetching notarization log:"
          xcrun notarytool log "$SUBMISSION_ID" --keychain-profile "AC_PROFILE" | cat || true

          # If wait.json indicates an error, fail the step explicitly
          STATUS=$(python3 -c "import json;print(json.load(open('notarytool_wait.json')).get('status',''))" || echo "")
          echo "Notarization status: $STATUS"
          if [ "$STATUS" != "Accepted" ]; then
            echo "Notarization did not complete successfully (status=$STATUS)" >&2
            exit 1
          fi

      - name: Staple notarization ticket to DMG
        run: |
          set -eo pipefail
          ARCH="${{ matrix.arch }}"
          DMG_PATH="release/mac/metavinci_desktop_${{ github.ref_name }}_${ARCH}.dmg"
          xcrun stapler staple "$DMG_PATH"
          echo "Validating stapled DMG:"
          xcrun stapler validate "$DMG_PATH" | cat || true

      - name: Upload macOS DMG installer
        uses: actions/upload-artifact@v4
        with:
          name: metavinci-macos-installer-${{ matrix.arch }}
          path: release/mac/*.dmg
          retention-days: 30

  create-release:
    runs-on: ubuntu-latest
    needs: [build-linux-installer, build-windows-installer, build-macos-installer]
    if: startsWith(github.ref, 'refs/tags/')
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download all installers
      uses: actions/download-artifact@v4
      with:
        path: installers

    - name: Prepare release assets
      run: |
        mkdir -p release
        
        # Linux .deb file
        cp installers/metavinci-linux-installer/*.deb release/ 2>/dev/null || echo "No Linux .deb files found"
        
        # Windows files (all in the root of the artifact)
        cp installers/metavinci-windows-msi-installer/*.msi release/ 2>/dev/null || echo "No Windows MSI files found"
        cp installers/metavinci-windows-msi-installer/install-win-metavinci-cert.ps1 release/ 2>/dev/null || echo "Certificate script not found"
        cp installers/metavinci-windows-msi-installer/heavymeta-code-sign.cer release/ 2>/dev/null || echo "Certificate file not found"
        
        # macOS DMG files
        
        # macOS DMG files
        cp installers/metavinci-macos-installer-amd64/*.dmg release/
        cp installers/metavinci-macos-installer-arm64/*.dmg release/

    - name: Upload release assets
      uses: actions/upload-artifact@v4
      with:
        name: metavinci-release
        path: release/
        retention-days: 90

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        files: release/*
        tag_name: ${{ github.ref_name }}
        name: Release ${{ github.ref_name }}
        body: |
          ## Metavinci ${{ github.ref_name }}
          
          Cross-platform release with executables for Linux, Windows, and macOS.
          
          ### Downloads
          - **Linux**: `.deb` package (x86_64)
          - **Windows**: `.msi` installer (x86_64)
          - **macOS (Intel/AMD)**: `.dmg` installer labeled `amd64`
          - **macOS (Apple Silicon)**: `.dmg` installer labeled `arm64`
          
          Please download the correct DMG for your Mac architecture.
          
          See README.md in the release for installation instructions.
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} 